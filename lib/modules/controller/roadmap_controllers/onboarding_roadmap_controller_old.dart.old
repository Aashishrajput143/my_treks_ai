// ignore_for_file: unused_local_variable

import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:math';

import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:vroar/modules/screen/roadmap/onboarding_roadmap_screen.dart';
import 'package:youtube_player_flutter/youtube_player_flutter.dart';

import '../../../common/common_widgets.dart';
import '../../../common/roadmap_common_widgets/roadmap_task_done_screen.dart';
import '../../../common/roadmap_common_widgets/youtube_video_player.dart';
import '../../../common/constants.dart';
import '../../../models/oboarding_roadmap_models.dart';
import '../../../models/upload_media_model.dart';
import '../../../resources/images.dart';
import '../../../routes/routes_class.dart';
import '../../../utils/roadmap_enums.dart';
import '../../../utils/utils.dart';
import '../../../common/common_methods.dart';
import '../../../data/response/status.dart';
import '../../../resources/strings.dart';
import '../../repository/roadmap_repository.dart';
import '../../repository/signup_repository.dart';
import '../../../common/shared_preference.dart';
// import '../../data/response/status.dart';

class OnBoardingRoadmapController extends GetxController with GetTickerProviderStateMixin {
  TransformationController transformationController = TransformationController();
  // CommonScreenController commonScreenController = Get.put(CommonScreenController());
  late AnimationController animationController;
  double minY = Platform.isAndroid ? -5000 : -4400; // Set the limit for downward movement
  RxInt lastUnlockedLevel = 0.obs;
  double imageHeight = 2048;
  double imageWidth = 2048;
  RxBool isLevelCompleted = false.obs;
  RxBool isOnBoardingRoadMap = false.obs;
  RxBool showUploadBtn = true.obs;
  RxBool showContinueBtn = false.obs;
  RxBool showInHouseVideo = false.obs;
  RxString inHouseVideoUrl = ''.obs;
  RxInt currIndex = 0.obs;
  RxInt currStepId = 0.obs;
  final int onBoardingLevelsRoadMap = 8;
  List<Offset> levelPositions = []; // Holds level positions for scrolling
  RxBool isImageLoaded = false.obs;
  late Image backgroundImage;
  var picker = FilePickerIO().obs;
  var selectedFile = Rxn<String>();
  var selectedFileSize = Rxn<String>();
  var selectedFilePath = Rxn<String>();
  RxString userName = ''.obs;
  RxString userImage = ''.obs;

  var couponController = TextEditingController().obs;
  var couponFocusNode = FocusNode().obs;

  var selectedImage = Rxn<String>();
  final api = SignupRepository();
  final uploadResultFile = UploadMediaModel().obs;
  void setUploadResultFile(UploadMediaModel value) => uploadResultFile.value = value;

  final StreamController<OnBoardingRoadmapJourneyModel> _roadmapStreamController = StreamController.broadcast();

  // Expose the stream
  Stream<OnBoardingRoadmapJourneyModel> get roadmapStream => _roadmapStreamController.stream;

  final getOnBoardingRoadmapData = OnBoardingRoadmapJourneyModel().obs;
  final getOnBoardingRoadmapUpdateResponse = OnBoardingRoadmapJourneyUpdateModel().obs;
  final onBoardRoadMapApi = RoadmapRepository();

  void setError(String value) => error.value = value;
  RxString error = ''.obs;
  final rxRequestStatus = Status.LOADING.obs;

  void setRxRequestStatus(Status value) {
    rxRequestStatus.value = value;
    update();
  }

  void setOnBoardingRoadmapData(OnBoardingRoadmapJourneyModel value) {
    getOnBoardingRoadmapData.value = value;
    _roadmapStreamController.add(value);
    setRxRequestStatus(Status.COMPLETED);
  }

  void setOnBoardingRoadmapUpdateResponse(OnBoardingRoadmapJourneyUpdateModel value) {
    getOnBoardingRoadmapUpdateResponse.value = value;
    // _roadmapStreamController.add(value);
    setRxRequestStatus(Status.COMPLETED);
  }

  @override
  void onInit() {
    super.onInit();
    preloadImage();
    // loadLastUnlockedLevel();
    initializeLevelPositions();
    transformationController.addListener(_checkBounds);
    // Initialize AnimationController at class level
    animationController = AnimationController(duration: const Duration(seconds: 2), vsync: this);
    getOnBoardingRoadmapApi();
  }

  @override
  void onClose() {
    transformationController.removeListener(_checkBounds);
    transformationController.dispose();
    _roadmapStreamController.close();
    animationController.dispose();
    super.onClose();
  }

  @override
  void onReady() {
    super.onReady();
    Future.delayed(const Duration(milliseconds: 300), () {
      scrollToLastUnlockedLevel(false, 0);
    });
  }

  void _checkBounds() {
    Matrix4 matrix = transformationController.value;
    double y = matrix.getTranslation().y;

    // Restrict downward movement if level >= 7
    if ((levelPositions.length >= 7 && y > minY) || lastUnlockedLevel.value >= 7 && y > minY) {
      transformationController.value = Matrix4.translationValues(
        matrix.getTranslation().x,
        GetPlatform.isAndroid ? (minY + 55) : minY,
        0,
      )..multiply(Matrix4.diagonal3Values(
          matrix.getMaxScaleOnAxis(),
          matrix.getMaxScaleOnAxis(),
          1,
        ));
    }
  }

  void preloadImage() async {
    backgroundImage = Image.asset('assets/images/roadmap_demo.png');

    // Ensure image is fully loaded before updating UI
    await precacheImage(backgroundImage.image, Get.context!);

    isImageLoaded.value = true;
    backgroundImage.image.resolve(const ImageConfiguration()).addListener(
      ImageStreamListener((_, __) {
        isImageLoaded.value = true; // Notify UI when image is ready
      }),
    );
    update();
  }

  void onInteractionEnd() {
    transformationController.toScene(Offset.zero);
    update();
  }

  void onChangeCurrentScreen(int index) {
    // commonScreenController.selectedIndex.value = index;
    update();
  }

  onClickUploadButton() {
    pickFileFromPhone().then((val) => {
          if (val.value != '')
            {
              showUploadBtn.value = false,
              showContinueBtn.value = true,
              update(),
            }
        });
  }

  revertBack() {
    showUploadBtn.value = true;
    showContinueBtn.value = false;
    selectedFile.value = "";
    selectedFileSize.value = "";
    selectedFilePath.value = "";
    update();
  }

  static String getFileSizeString({required int bytes, int decimals = 0}) {
    const suffixes = ["b", "kb", "mb", "gb", "tb"];
    if (bytes == 0) return '0${suffixes[0]}';
    var i = (log(bytes) / log(1024)).floor();
    return ((bytes / pow(1024, i)).toStringAsFixed(decimals)) + suffixes[i];
  }

  Future pickFileFromPhone() async {
    FilePickerResult? result = await FilePicker.platform.pickFiles(type: FileType.custom, allowedExtensions: ['pdf']);
    if (result != null) {
      Utils.printLog(result.files.first.path.toString());
      XFile file = XFile(result.files.first.path!);
      selectedFile.value = result.files.first.name;
      selectedFilePath.value = result.files.first.path;
      var fileSize = getFileSizeString(bytes: result.files.first.size);
      selectedFileSize.value = fileSize.toString();
      Utils.printLog(fileSize);
    }
    Utils.printLog(result);
    return selectedFile;
  }

  Future<bool> levelTagColor(index) async => await AppPreferences.isOnBoardingLevelCompleted(index);

  Future<void> markLevelCompleted(int level, int stepId) async {
    if (!await CommonMethods.checkInternetConnectivity()) {
      CommonMethods.showToast(appStrings.weUnableCheckData);
      return;
    }

    if (level < lastUnlockedLevel.value) {
      return loadLastUnlockedLevel();
    }

    try {
      // setRxRequestStatus(Status.LOADING);
      await AppPreferences.saveOnBoardingLevelCompleted(level);
      SharedPreferences prefs = await SharedPreferences.getInstance();
      OnBoardingRoadmapJourneyUpdatePostModel data = OnBoardingRoadmapJourneyUpdatePostModel(id: int.parse(getOnBoardingRoadmapData.value.data!.id!), levelCompleted: getOnBoardingRoadmapData.value.data!.levelCompleted! + 1, completedStepId: stepId);
      await onBoardRoadMapApi.onBoardingRoadmapLevelUpdate(data).then((value) async {
        setOnBoardingRoadmapUpdateResponse(value);
        //CommonMethods.showToastSuccess("${value.message}");
        Utils.printLog("Response===> ${value.toString()}");
        if (getOnBoardingRoadmapUpdateResponse.value.statusCode == 200) {
          await prefs.setInt(Constants.onBoardingLastUnlockedLevel, level + 1); // Ensure next level unlocks

          lastUnlockedLevel.value = level + 1; // Ensure reactive state updates
          update();
          await getOnBoardingRoadmapApi();
          loadLastUnlockedLevel();
          setRxRequestStatus(Status.COMPLETED);
        }
      });
    } catch (e) {
      handleApiError(e);
      Utils.printLog(e);
    }
  }

  Future<void> markLevelCompletedOnly(int level) async {
    await AppPreferences.saveOnBoardingLevelCompleted(level);

    SharedPreferences prefs = await SharedPreferences.getInstance();

    await prefs.setInt(Constants.onBoardingLastUnlockedLevel, level + 1); // Ensure next level unlocks

    lastUnlockedLevel.value = level + 1; // Ensure reactive state updates
    update();
    await getOnBoardingRoadmapApi();
    loadLastUnlockedLevel();
  }

  Future<void> loadLastUnlockedLevel() async {
    // SharedPreferences prefs = await SharedPreferences.getInstance();
    // lastUnlockedLevel.value = prefs.getInt('lastUnlockedLevel') ?? 0;

    Utils.getIntPreferenceValues(Constants.onBoardingLastUnlockedLevel).then((val) => {
          // Scroll to last unlocked level after loading (Ensure UI updates)
          lastUnlockedLevel.value = val ?? 0,
          Future.delayed(const Duration(milliseconds: 300), () {
            scrollToLastUnlockedLevel(false, 0);
          }),
        });
  }

  Future<void> scrollToLastUnlockedLevel(bool callCompletedLevel, int level) async {
    // First, let's log the incoming parameters
    Utils.printLog("SCROLL DEBUG - Input params: callCompletedLevel=$callCompletedLevel, explicit level=$level");

    // Get and log the stored level
    SharedPreferences prefs = await SharedPreferences.getInstance();
    int storedLevel = prefs.getInt(Constants.onBoardingLastUnlockedLevel) ?? 0;
    Utils.printLog("SCROLL DEBUG - Stored level from SharedPreferences: $storedLevel");

    // Determine which level we're targeting
    int targetLevel = callCompletedLevel ? level : storedLevel;
    Utils.printLog("SCROLL DEBUG - Final target level: $targetLevel");

    // Check if levelPositions is properly initialized
    if (levelPositions.isEmpty) {
      Utils.printLog("SCROLL DEBUG - ERROR: levelPositions is empty!");
      return;
    }
    Utils.printLog("SCROLL DEBUG - levelPositions count: ${levelPositions.length}");

    // Ensure we stay within bounds
    int safeLevelIndex = targetLevel.clamp(0, levelPositions.length - 1);
    Utils.printLog("SCROLL DEBUG - Final safe level index: $safeLevelIndex");

    // Get target position
    Offset targetOffset = levelPositions[safeLevelIndex];
    Utils.printLog("SCROLL DEBUG - Target offset for level $safeLevelIndex: $targetOffset");

    // Get current transformation matrix
    Matrix4 currentMatrix = transformationController.value.clone();
    double currentX = currentMatrix.storage[12];
    double currentY = currentMatrix.storage[13];
    Utils.printLog("SCROLL DEBUG - Current matrix position: x=$currentX, y=$currentY");

    // Calculate position based on the specific level
    double moveX = 0;
    double moveY = 0;

    // Custom positioning for each level range
    if (safeLevelIndex >= 7) {
      // Level 7+: Position near the top of the image
      moveX = -targetOffset.dx + (Get.width / 3);
      moveY = minY; // Use the minY boundary directly
      Utils.printLog("SCROLL DEBUG - Using high level adjustment (7+)");
    } else if (safeLevelIndex < 3) {
      // Levels 0-2: Position near the bottom of the image
      moveX = -targetOffset.dx + (Get.width / 2);
      moveY = -targetOffset.dy + (Get.height * 0.75);
      Utils.printLog("SCROLL DEBUG - Using low level adjustment (0-2)");
    } else if (safeLevelIndex >= 3 && safeLevelIndex < 5) {
      // Levels 3-4: Mid-low position
      moveX = -targetOffset.dx + (Get.width / 2);
      moveY = -targetOffset.dy + (Get.height * 0.75);
      Utils.printLog("SCROLL DEBUG - Using mid-low level adjustment (3-4)");
    } else {
      // Levels 5-6: Mid-high position
      moveX = -targetOffset.dx + (Get.width / 2);
      moveY = -targetOffset.dy + (Get.height * 0.5);
      Utils.printLog("SCROLL DEBUG - Using mid-high level adjustment (5-6)");
    }

    // Apply bounds checking to ensure we stay within the image
    moveX = moveX.clamp(-imageWidth + Get.width, 0);

    // For Y bounds, respect the minY value for levels >= 7
    if (safeLevelIndex >= 7) {
      // For high levels, strictly enforce minY
      moveY = moveY.clamp(minY, 0);
    } else {
      // For lower levels, use a different range
      double lowerLevelMinY = Platform.isAndroid ? -6500 : -6000;
      moveY = moveY.clamp(lowerLevelMinY, 0);
    }

    Utils.printLog("SCROLL DEBUG - Final bounded position: x=$moveX, y=$moveY");

    // Create target transformation matrix
    Matrix4 targetMatrix = Matrix4.identity()..translate(moveX, moveY, 0);

    // Stop any ongoing animation
    if (animationController.isAnimating) {
      animationController.stop();
    }

    // Reset the animation duration
    // animationController.duration = Duration(milliseconds: 1200);

    // Use Matrix4Tween for smooth animation
    final matrixTween = Matrix4Tween(begin: currentMatrix, end: targetMatrix);

    // Clear previous listeners to avoid conflicts
    // animationController.clearListeners();

    Animation<Matrix4> animation = matrixTween.animate(
      CurvedAnimation(parent: animationController, curve: Curves.easeOutQuad),
    );

    animation.addListener(() {
      transformationController.value = animation.value;
      update(); // Notify GetX UI
    });

    Utils.printLog("SCROLL DEBUG - Starting animation to level $safeLevelIndex");
    await animationController.forward(from: 0);
    Utils.printLog("SCROLL DEBUG - Animation completed to level $safeLevelIndex");

    // Update lastUnlockedLevel after animation completes
    lastUnlockedLevel.value = safeLevelIndex;
    update(); // Final update
  }

  void initializeLevelPositions() {
    levelPositions = const [
      // Offset(1030, 1960), //0
      // Offset(990.5, 1870.5), //1
      // Offset(900.8, 1830.0), //2
      // Offset(910.5, 1700.7), //3
      // Offset(990.5, 1575.0), //4
      // Offset(910.5, 1513.3), //5
      // Offset(820.5, 1440.7), //6
      // Offset(840.5, 1320.3), //7
      // Offset(2105, 7580), //1
      // Offset(2140.5, 7270.5), //2
      Offset(2105, 7460), //0
      Offset(2040.5, 7170.5), //1
      Offset(1600.8, 6730.0), //2
      Offset(1740.5, 6320.7), //3
      Offset(1950.5, 6075.0), //4
      Offset(1710.5, 5913.3), //5
      Offset(1320.5, 5440.7), //6
      Offset(1700.5, 4760.3), //7
    ];
  }

  Future<void> uploadFileApi() async {
    if (!await CommonMethods.checkInternetConnectivity()) {
      CommonMethods.showToast(appStrings.weUnableCheckData);
      return;
    }

    if (selectedFilePath.value?.isEmpty == null) {
      CommonMethods.showToastSuccess("Please select a file to upload!");
      return;
    }

    setRxRequestStatus(Status.LOADING);

    String? userId = await Utils.getPreferenceValues(Constants.userId);
    if (userId == null || userId.isEmpty) {
      CommonMethods.showToast("User ID not found!");
      setRxRequestStatus(Status.ERROR);
      return;
    }

    Utils.printLog("Uploading file for user: $userId");

    try {
      final response = await api.uploadApi(selectedFilePath.value, 'GALLUP_RESULT', userId);
      setUploadResultFile(response);
      setRxRequestStatus(Status.COMPLETED);
      Utils.printLog("Upload Response: ${response.toString()}");
    } catch (error) {
      handleApiError(error);
    }
  }

  void handleApiError(dynamic error) {
    setError(error.toString());
    setRxRequestStatus(Status.ERROR);

    if (error.toString().contains("{")) {
      try {
        var errorResponse = json.decode(error.toString());
        String message = errorResponse['message'] ?? "An unexpected error occurred.";
        CommonMethods.showToast(message);
      } catch (_) {
        CommonMethods.showToast("An unexpected error occurred.");
      }
    }

    Utils.printLog("API Error: $error");
  }

  Future<void> getOnBoardingRoadmapApi() async {
    if (!await CommonMethods.checkInternetConnectivity()) {
      CommonMethods.showToast(appStrings.weUnableCheckData);
      return;
    }

    userName.value = await Utils.getPreferenceValues(Constants.firstName) ?? '';
    userImage.value = await Utils.getPreferenceValues(Constants.avatar) ?? '';

    try {
      final roadmapData = await onBoardRoadMapApi.getOnBoardingRoadmapApi();
      setOnBoardingRoadmapData(roadmapData);

      int completedSteps = roadmapData.data?.completedSteps?.length ?? 1;
      if (completedSteps == 1 || completedSteps - 1 == lastUnlockedLevel.value) {
        lastUnlockedLevel.value = completedSteps;
        await AppPreferences.saveOnBoardingLevelCompleted(lastUnlockedLevel.value);
        await (await SharedPreferences.getInstance()).setInt(Constants.onBoardingLastUnlockedLevel, lastUnlockedLevel.value);
        scrollToLastUnlockedLevel(false, 0);
      } else {
        loadLastUnlockedLevel();
      }

      setRxRequestStatus(Status.COMPLETED);
      Utils.printLog("Roadmap Data Loaded: ${roadmapData.toString()}");
    } catch (error) {
      handleApiError(error);
    }
  }

  playYtVideo(url, int? currIndex, int? stepId) {
    String? videoId;
    videoId = YoutubePlayer.convertUrlToId(url);
    // videoId = YoutubePlayer.convertUrlToId("https://www.youtube.com/watch?v=IhPcbusMv1g");
    Utils.printLog(videoId);
    Get.to(() => YouTubeVideoPlayerWidget(videoId: videoId!));
  }

  onClickGallupVideo(url, level, stepId) {
    playVideo(url).then(() => {markLevelCompleted(level, stepId)});
  }

  playVideo(url) {
    // Get.to(() => VideoPlayerWidget(videoUrl: url));
    inHouseVideoUrl.value = url;
    showInHouseVideo.value = true;
    update();
  }

  hideVideoPlayWidget() {
    showInHouseVideo.value = false;
    update();
  }

  googleMeet(String url) async {
    final uri = Uri.parse(url);
    await launchUrl(uri, mode: LaunchMode.externalApplication);
  }

  updateCurrIndexStepId(index, stepId) {
    currIndex.value = index;
    currStepId.value = stepId;
    update();
  }

  // Future<void> uploadFileApi() async {
  //   var connection = await CommonMethods.checkInternetConnectivity();
  //   Utils.printLog("CheckInternetConnection===> ${connection.toString()}");
  //   String userId = "";
  //   String filePath = selectedFilePath.value ?? '';
  //   if (filePath.isEmpty) {
  //     CommonMethods.showToastSuccess("Please select file to upload!!");
  //   } else if (connection == true) {
  //     setRxRequestStatus(Status.LOADING);

  //     String mediaLibraryType = 'GALLUP_RESULT';
  //     await Utils.getPreferenceValues(Constants.userId).then((value) async {
  //       Utils.printLog("userId $value");
  //       userId = value;
  //     });
  //     Utils.printLog"userIdfsdfas=>$userId");

  //     await api.uploadApi(filePath, mediaLibraryType, userId).then((value) {
  //       setRxRequestStatus(Status.COMPLETED);
  //       setUploadResultFile(value);
  //       // CommonMethods.showToastSuccess("${value.message}");
  //       Utils.printLog("Response===> ${value.toString()}");
  //     }).onError((error, stackTrace) {
  //       setError(error.toString());
  //       setRxRequestStatus(Status.ERROR);
  //       if (error.toString().contains("{")) {
  //         var errorResponse = json.decode(error.toString());
  //         Utils.printLog"errrrorrr=====>$errorResponse");
  //         if (errorResponse is Map || errorResponse.containsKey('message')) {
  //           CommonMethods.showToast(errorResponse['message']);
  //         } else {
  //           CommonMethods.showToast("An unexpected error occurred.");
  //         }
  //       }
  //       Utils.printLog("Error===> ${error.toString()}");
  //       Utils.printLog("stackTrace===> ${stackTrace.toString()}");
  //     });
  //   } else {
  //     CommonMethods.showToast(appStrings.weUnableCheckData);
  //   }
  // }

  OnBoardingRoadMapContentType? getEnumFromValue(String value) {
    return OnBoardingRoadMapContentType.values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw ArgumentError("Invalid value: $value"),
    );
  }

  Future<void> handleAction(String type, bool isCurrent, String contentType, bool isCompleted, String inHouseVideoUrl, String? contentLink, int stepId, String assessmentId, int index) async {
    final onBoardRoadmapScreen = OnBoardingRoadmapScreen();
    OnBoardingRoadMapContentType? onContentType = getEnumFromValue(type);
    switch (onContentType) {
      case OnBoardingRoadMapContentType.onBoardVideo:
        OnBoardingRoadMapContentType? onContentType = getEnumFromValue(contentType);
        switch (onContentType) {
          case OnBoardingRoadMapContentType.nativeVideo:
            isCurrent && !isCompleted
                ? onBoardRoadmapScreen.openVideoDialog(() {
                    Get.back();
                    onBoardRoadmapScreen.roadmapController.markLevelCompleted(0, stepId);
                    onBoardRoadmapScreen.videoCompleteDialog(contentLink, "video");
                  }, () {
                    Get.back();
                    onBoardRoadmapScreen.roadmapController.playVideo(contentLink);
                    onBoardRoadmapScreen.playVideoInPopUp(contentLink);
                    // playVideoInPopUp(url);
                  }, "video")
                : onBoardRoadmapScreen.videoCompleteDialog(contentLink, "video");
            break;
          case OnBoardingRoadMapContentType.youtubeVideo:
            isCurrent && !isCompleted
                ? onBoardRoadmapScreen.openVideoDialog(() {
                    Get.back();
                    onBoardRoadmapScreen.roadmapController.markLevelCompleted(0, stepId);
                    onBoardRoadmapScreen.videoCompleteDialog(contentLink, "youtube");
                  }, () {
                    Get.back();
                    playYtVideo(contentLink, index, stepId);
                    // playVideoInPopUp(url);
                  }, "youtube")
                : onBoardRoadmapScreen.videoCompleteDialog(contentLink, "youtube");
            break;
          default:
            Utils.printLog("Unsupported video content type: $contentType");
        }
      case OnBoardingRoadMapContentType.assessment:
        isCurrent && !isCompleted
            ? onBoardRoadmapScreen.assignmentDialog(() {
                Get.back();
                Get.toNamed(RoutesClass.questionAnswer, arguments: [
                  {'stepId': stepId},
                  {'assessmentId': assessmentId},
                  {'currentLevel': index},
                  {'assessmentType': 'ASSESSMENT'}
                ]);
              }, false)
            : onBoardRoadmapScreen.assignmentCompletedDialog(() {
                Get.back();
              }, false);
        break;
      case OnBoardingRoadMapContentType.softSkillAssessment:
        isCurrent && !isCompleted
            ? onBoardRoadmapScreen.assignmentDialog(() {
                Get.back();
                Get.toNamed(RoutesClass.questionAnswer, arguments: [
                  {'stepId': stepId},
                  {'assessmentId': assessmentId},
                  {'currentLevel': index},
                  {'assessmentType': 'SOFT_SKILL_ASSESSMENT'}
                ]);
              }, true)
            : onBoardRoadmapScreen.assignmentCompletedDialog(() {
                Get.back();
              }, true);
        // Handle assessment logic (assuming there's an assessment dialog)
        // openAssessmentDialog();
        break;

      case OnBoardingRoadMapContentType.gallupVideo:
        OnBoardingRoadMapContentType? onContentType = getEnumFromValue(contentType);
        switch (onContentType) {
          case OnBoardingRoadMapContentType.nativeVideo:
            isCurrent && !isCompleted
                ? onBoardRoadmapScreen.openVideoDialog(() {
                    Get.back();
                    onBoardRoadmapScreen.roadmapController.markLevelCompleted(0, stepId);
                    onBoardRoadmapScreen.videoCompleteDialog(contentLink, "video");
                  }, () {
                    Get.back();
                    onBoardRoadmapScreen.roadmapController.playVideo(contentLink);
                    onBoardRoadmapScreen.playVideoInPopUp(contentLink);
                    // playVideoInPopUp(url);
                  }, "video")
                : onBoardRoadmapScreen.videoCompleteDialog(contentLink, "video");
            break;
          case OnBoardingRoadMapContentType.youtubeVideo:
            isCurrent && !isCompleted
                ? onBoardRoadmapScreen.openVideoDialog(() {
                    Get.back();
                    onBoardRoadmapScreen.roadmapController.markLevelCompleted(0, stepId);
                    onBoardRoadmapScreen.videoCompleteDialog(contentLink, "youtube");
                  }, () {
                    Get.back();
                    playYtVideo(contentLink, index, stepId);
                    // playVideoInPopUp(url);
                  }, "youtube")
                : onBoardRoadmapScreen.videoCompleteDialog(contentLink, "youtube");
            break;
          default:
            Utils.printLog("Unsupported video content type: $contentType");
        }
        break;
      case OnBoardingRoadMapContentType.coachVideo:
        OnBoardingRoadMapContentType? onContentType = getEnumFromValue(contentType);
        switch (onContentType) {
          case OnBoardingRoadMapContentType.nativeVideo:
            isCurrent && !isCompleted
                ? onBoardRoadmapScreen.openVideoDialog(() {
                    Get.back();
                    onBoardRoadmapScreen.roadmapController.markLevelCompleted(0, stepId);
                    onBoardRoadmapScreen.videoCompleteDialog(contentLink, "video");
                  }, () {
                    Get.back();
                    onBoardRoadmapScreen.roadmapController.playVideo(contentLink);
                    onBoardRoadmapScreen.playVideoInPopUp(contentLink);
                    // playVideoInPopUp(url);
                  }, "video")
                : onBoardRoadmapScreen.videoCompleteDialog(contentLink, "video");
            break;
          case OnBoardingRoadMapContentType.youtubeVideo:
            isCurrent && !isCompleted
                ? onBoardRoadmapScreen.openVideoDialog(() {
                    Get.back();
                    onBoardRoadmapScreen.roadmapController.markLevelCompleted(0, stepId);
                    onBoardRoadmapScreen.videoCompleteDialog(contentLink, "youtube");
                  }, () {
                    Get.back();
                    playYtVideo(contentLink, index, stepId);
                    // playVideoInPopUp(url);
                  }, "youtube")
                : onBoardRoadmapScreen.videoCompleteDialog(contentLink, "youtube");
            break;
          default:
            Utils.printLog("Unsupported video content type: $contentType");
        }
        break;

      case OnBoardingRoadMapContentType.userInviteGallupCode:
        // openSessionCompleteDialog();
        updateCurrIndexStepId(index, stepId);
        Get.to(() => RoadmapTaskDoneScreen(
              image: appImages.lockFullIcon,
              titleText: appStrings.codeTitle,
              buttonHint: appStrings.inviteParent,
              button2Hint: appStrings.enterCouponCode,
              subText: appStrings.codeDescription,
              onComplete: () => Get.toNamed(RoutesClass.parentInvite, arguments: [
                {'isOnBoarding': true},
                {"skip": false}
              ]),
              navigate: () async {
                bottomCodeDrawer(couponController.value, couponFocusNode.value, () {
                  Get.back();
                  Get.back();
                  print(couponController.value.text);
                  couponController.value.text == "PAY-5000" ? markLevelCompleted(index, stepId) : null;
                });
              },
            ));
        // Get.toNamed(RoutesClass.parentInvite, arguments: [
        //   {'isOnBoarding': true}
        // ]);
        break;

      case OnBoardingRoadMapContentType.gallupResult:
        updateCurrIndexStepId(index, stepId);
        onBoardRoadmapScreen.resultUploadDialog();
        break;

      case OnBoardingRoadMapContentType.scheduleCoachmeeting:
        googleMeet(inHouseVideoUrl);
        break;

      default:
        Utils.printLog("Invalid type: $type");
    }
  }
}
